/* Autogenerated by /usr/bin/halcompile on Fri Jun 14 17:50:20 2024 -- do not edit */
#include "rtapi.h"
#ifdef RTAPI
#include "rtapi_app.h"
#endif
#include "rtapi_string.h"
#include "rtapi_errno.h"
#include "hal.h"
#include "rtapi_math64.h"

static int comp_id;

#ifdef MODULE_INFO
MODULE_INFO(linuxcnc, "component:groot_error:groot_error");
MODULE_INFO(linuxcnc, "author:Guido HÃ¼ttemann");
MODULE_INFO(linuxcnc, "license:GPL");
MODULE_INFO(linuxcnc, "pin:emc_running:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:emc_enable_in:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:emc_enable_out:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:emc_on:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:emc_auto:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:auto_enable:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:spindle_enable_in:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:spindle_enable_out:bit:0:out::None:None");
MODULE_INFO(linuxcnc, "pin:estop_pendant:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:estop_external:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:vfd_err:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:spindle_temp_err:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:air_ok:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:vfd_error_code:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:tls_overtravel:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:error:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:ec_slaves:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:ec_slaves_responding:u32:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:ec_link_up:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:ec_all_op:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "pin:matprobe_cyl_err:bit:0:in::None:None");
MODULE_INFO(linuxcnc, "funct:_:1:");
MODULE_LICENSE("GPL");
#endif // MODULE_INFO


struct __comp_state {
    struct __comp_state *_next;
    hal_bit_t *emc_running;
    hal_bit_t *emc_enable_in;
    hal_bit_t *emc_enable_out;
    hal_bit_t *emc_on;
    hal_bit_t *emc_auto;
    hal_bit_t *auto_enable;
    hal_bit_t *spindle_enable_in;
    hal_bit_t *spindle_enable_out;
    hal_bit_t *estop_pendant;
    hal_bit_t *estop_external;
    hal_bit_t *vfd_err;
    hal_bit_t *spindle_temp_err;
    hal_bit_t *air_ok;
    hal_u32_t *vfd_error_code;
    hal_bit_t *tls_overtravel;
    hal_bit_t *error;
    hal_u32_t *ec_slaves;
    hal_u32_t *ec_slaves_responding;
    hal_bit_t *ec_link_up;
    hal_bit_t *ec_all_op;
    hal_bit_t *matprobe_cyl_err;
    void *_data;
};
struct __comp_state *__comp_first_inst=0, *__comp_last_inst=0;

static void _(struct __comp_state *__comp_inst, long period);
static int __comp_get_data_size(void);
static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg);
#undef TRUE
#define TRUE (1)
#undef FALSE
#define FALSE (0)
#undef true
#define true (1)
#undef false
#define false (0)

static int export(char *prefix, long extra_arg) {
    char buf[HAL_NAME_LEN + 1];
    int r = 0;
    int sz = sizeof(struct __comp_state) + __comp_get_data_size();
    struct __comp_state *inst = hal_malloc(sz);
    memset(inst, 0, sz);
    inst->_data = (char*)inst + sizeof(struct __comp_state);
    r = extra_setup(inst, prefix, extra_arg);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->emc_running), comp_id,
        "%s.emc-running", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->emc_enable_in), comp_id,
        "%s.emc-enable-in", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->emc_enable_out), comp_id,
        "%s.emc-enable-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->emc_on), comp_id,
        "%s.emc-on", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->emc_auto), comp_id,
        "%s.emc-auto", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->auto_enable), comp_id,
        "%s.auto-enable", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->spindle_enable_in), comp_id,
        "%s.spindle-enable-in", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_OUT, &(inst->spindle_enable_out), comp_id,
        "%s.spindle-enable-out", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->estop_pendant), comp_id,
        "%s.estop-pendant", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->estop_external), comp_id,
        "%s.estop-external", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->vfd_err), comp_id,
        "%s.vfd-err", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->spindle_temp_err), comp_id,
        "%s.spindle-temp-err", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->air_ok), comp_id,
        "%s.air-ok", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->vfd_error_code), comp_id,
        "%s.vfd-error-code", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->tls_overtravel), comp_id,
        "%s.tls-overtravel", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->error), comp_id,
        "%s.error", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->ec_slaves), comp_id,
        "%s.ec-slaves", prefix);
    if(r != 0) return r;
    r = hal_pin_u32_newf(HAL_IN, &(inst->ec_slaves_responding), comp_id,
        "%s.ec-slaves-responding", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ec_link_up), comp_id,
        "%s.ec-link-up", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->ec_all_op), comp_id,
        "%s.ec-all-op", prefix);
    if(r != 0) return r;
    r = hal_pin_bit_newf(HAL_IN, &(inst->matprobe_cyl_err), comp_id,
        "%s.matprobe-cyl-err", prefix);
    if(r != 0) return r;
    rtapi_snprintf(buf, sizeof(buf), "%s", prefix);
    r = hal_export_funct(buf, (void(*)(void *inst, long))_, inst, 1, 0, comp_id);
    if(r != 0) return r;
    if(__comp_last_inst) __comp_last_inst->_next = inst;
    __comp_last_inst = inst;
    if(!__comp_first_inst) __comp_first_inst = inst;
    return 0;
}
int rtapi_app_main(void) {
    int r = 0;
    comp_id = hal_init("groot_error");
    if(comp_id < 0) return comp_id;
    r = export("groot-error", 0);
    if(r) {
        hal_exit(comp_id);
    } else {
        hal_ready(comp_id);
    }
    return r;
}

void rtapi_app_exit(void) {
    hal_exit(comp_id);
}

#undef FUNCTION
#define FUNCTION(name) static void name(struct __comp_state *__comp_inst, long period)
#undef EXTRA_SETUP
#define EXTRA_SETUP() static int extra_setup(struct __comp_state *__comp_inst, char *prefix, long extra_arg)
#undef EXTRA_CLEANUP
#define EXTRA_CLEANUP() static void extra_cleanup(void)
#undef fperiod
#define fperiod (period * 1e-9)
#undef emc_running
#define emc_running (0+*__comp_inst->emc_running)
#undef emc_enable_in
#define emc_enable_in (0+*__comp_inst->emc_enable_in)
#undef emc_enable_out
#define emc_enable_out (*__comp_inst->emc_enable_out)
#undef emc_on
#define emc_on (0+*__comp_inst->emc_on)
#undef emc_auto
#define emc_auto (0+*__comp_inst->emc_auto)
#undef auto_enable
#define auto_enable (0+*__comp_inst->auto_enable)
#undef spindle_enable_in
#define spindle_enable_in (0+*__comp_inst->spindle_enable_in)
#undef spindle_enable_out
#define spindle_enable_out (*__comp_inst->spindle_enable_out)
#undef estop_pendant
#define estop_pendant (0+*__comp_inst->estop_pendant)
#undef estop_external
#define estop_external (0+*__comp_inst->estop_external)
#undef vfd_err
#define vfd_err (0+*__comp_inst->vfd_err)
#undef spindle_temp_err
#define spindle_temp_err (0+*__comp_inst->spindle_temp_err)
#undef air_ok
#define air_ok (0+*__comp_inst->air_ok)
#undef vfd_error_code
#define vfd_error_code (0+*__comp_inst->vfd_error_code)
#undef tls_overtravel
#define tls_overtravel (0+*__comp_inst->tls_overtravel)
#undef error
#define error (0+*__comp_inst->error)
#undef ec_slaves
#define ec_slaves (0+*__comp_inst->ec_slaves)
#undef ec_slaves_responding
#define ec_slaves_responding (0+*__comp_inst->ec_slaves_responding)
#undef ec_link_up
#define ec_link_up (0+*__comp_inst->ec_link_up)
#undef ec_all_op
#define ec_all_op (0+*__comp_inst->ec_all_op)
#undef matprobe_cyl_err
#define matprobe_cyl_err (0+*__comp_inst->matprobe_cyl_err)
#undef data
#define data (*(sbs_err_data*)(__comp_inst->_data))


#line 43 "groot_error.comp"

#define VFD_ERROR_STO  76

typedef struct {
  int last_estop_pendant;
  int last_estop_external;
  int last_vfd_err;
  int last_spindle_temp_err;
  int last_air_ok;
  int last_tls_overtravel;

  
  int last_auto_err;
  int last_ec_slaves_responding_ok;
  int last_ec_link_up;
  int last_ec_all_op;

} sbs_err_data;

EXTRA_SETUP() {
  data.last_estop_pendant = 0;
  data.last_estop_external = 0;
  data.last_vfd_err = 0;
  data.last_air_ok = 1;
  data.last_tls_overtravel = 0;
  data.last_auto_err = 0;
  data.last_ec_slaves_responding_ok = 1;
  data.last_ec_link_up = 1;
  data.last_ec_all_op = 1;
  return 0;
}

FUNCTION(_) {
  int ec_slaves_responding_ok;

  emc_enable_out = emc_running && emc_enable_in;
  spindle_enable_out = spindle_enable_in && auto_enable;

  // check if emc is on
  if (!emc_on) {
    data.last_estop_pendant = 0;
    data.last_estop_external = 0;
    data.last_vfd_err = 0;
    data.last_spindle_temp_err = 0;
    data.last_air_ok = 1;
    data.last_tls_overtravel = 0;
    data.last_auto_err = 0;
    data.last_ec_slaves_responding_ok = 1;
    data.last_ec_link_up = 1;
    data.last_ec_all_op = 1;

    return;
  }



  if (estop_pendant) {
    if (!data.last_estop_pendant) {
      rtapi_print_msg(RTAPI_MSG_ERR, "E-Stop pendant!\n");
    }
  }
  data.last_estop_pendant = estop_pendant;

  if (estop_external) {
    if (!data.last_estop_external) {
      rtapi_print_msg(RTAPI_MSG_ERR, "E-Stop safety relay!\n");
    }
  }
  data.last_estop_external = estop_external;

  if (vfd_err && vfd_error_code != VFD_ERROR_STO) {
    emc_enable_out = 0;
    if (!data.last_vfd_err) {
      rtapi_print_msg(RTAPI_MSG_ERR, "Spindle drive error!\n");
    }
  }
  data.last_vfd_err = vfd_err;

  if (spindle_temp_err) {
    emc_enable_out = 0;
    if (!data.last_spindle_temp_err) {
      rtapi_print_msg(RTAPI_MSG_ERR, "Spindle overtemp error!\n");
    }
  }
  data.last_spindle_temp_err = spindle_temp_err;

  if (!air_ok) {
    emc_enable_out = 0;
    if (data.last_air_ok) {
      rtapi_print_msg(RTAPI_MSG_ERR, "Air failure (pressure below treshold)!\n");
    }
  }
  data.last_air_ok = air_ok;

  if (!tls_overtravel) {
    emc_enable_out = 0;
    if (data.last_tls_overtravel) {
      rtapi_print_msg(RTAPI_MSG_ERR, "TLS overtravel!\n");
    }
  }
  data.last_tls_overtravel = air_ok;

  if ((emc_auto || spindle_enable_in) && !auto_enable) {
    emc_enable_out = 0;
    if (!data.last_auto_err) {
      rtapi_print_msg(RTAPI_MSG_ERR, "Automatic mode disabled!\n");
    }
    data.last_auto_err = 1;
  } else {
    data.last_auto_err = 0;
  }

  ec_slaves_responding_ok = (ec_slaves_responding == ec_slaves);
  if (!ec_slaves_responding_ok) {
    emc_enable_out = 0;
    if (data.last_ec_slaves_responding_ok) {
      rtapi_print_msg(RTAPI_MSG_ERR, "EtherCAT: Not all %d slaves responding!\n", ec_slaves);
    }
  }
  data.last_ec_slaves_responding_ok = ec_slaves_responding_ok;

  if (!ec_link_up) {
    emc_enable_out = 0;
    if (data.last_ec_link_up) {
      rtapi_print_msg(RTAPI_MSG_ERR, "EtherCAT: Link down!\n");
    }
  }
  data.last_ec_link_up = ec_link_up;

  if (!ec_all_op) {
    emc_enable_out = 0;
    if (data.last_ec_all_op) {
      rtapi_print_msg(RTAPI_MSG_ERR, "EtherCAT: Not all slaves in OP mode!\n");
    }
  }
  data.last_ec_all_op = ec_all_op;
}
static int __comp_get_data_size(void) { return sizeof(sbs_err_data); }
